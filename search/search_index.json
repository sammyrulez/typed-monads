{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Typed Monads","text":"<p>Monads have a reputation for being difficult to understand, but in this module  we provide a simple Python implementation of different monadic tools.   This will hopefully give some insight into what monads are all about.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install typed-monads \n</code></pre>"},{"location":"#building-form-source","title":"Building form source","text":"<pre><code>$ git clone git@github.com:sammyrulez/typed-monads.git\n$ cd typed-monads\n$ python setup.py test\n$ python setup.py install\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you find somthing odd open a bug type issue. Even better if you submit also a PR! Also feature request are welome!</p>"},{"location":"#project-layout","title":"Project layout","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This is a fork of the original work by  Correl Roush</p> <p>I added some utility methods to make it easier to use in my day to day code and better interate with the pythonic style ( ie List Comprehension )</p> <p>Some of the functional programming terms descriptions are taken from Wikipedia.</p>"},{"location":"applicative/","title":"Applicative","text":"<p>Applicative functors, or an applicative for short, allow for functorial computations to be sequenced (unlike plain functors), but don't allow using results from prior computations in the definition of subsequent ones (unlike monads). Applicative functors are the programming equivalent of lax monoidal functors with tensorial strength in category theory.</p> <p>Extends <code>Functor</code>.</p>"},{"location":"applicative/#pure","title":"pure","text":"<p>Wraps a value in an applicative functor.</p> <p>e.g.:</p> <pre><code>Maybe.pure(\"abc\") == Just(\"abc\")\nResult.pure(123) == Ok(123)\n</code></pre>"},{"location":"applicative/#apply","title":"apply (<code>&amp;</code>)","text":"<p>Transforms the value contained in the instance's functor with a function wrapped in the same type of functor.</p> <p>The <code>&amp;</code> operator implements apply on applicatives, and is right-associative.</p> <p>e.g.:</p> <pre><code>increment = lambda x: x + 1\n\nJust(3).apply(Just(increment)) == Just(increment) &amp; Just(3) == Just(4)\n</code></pre> <p>This can be very handily combined with map to apply curried functions to multiple arguments:</p> <pre><code>subtract = lambda x: lambda y: x - y\n\nsubtract * Just(10) &amp; Just(4) == Just(6)\n</code></pre>"},{"location":"curring/","title":"Curring","text":"<p>Curring is not a monad: it is the technique of converting a function that takes multiple arguments into a sequence of functions that each take a single argument.  It was introduced by Gottlob Frege developed by Moses Sch\u00f6nfinkel, and further developed by Haskell Curry.</p> <p>Mixing Higher order functions ( functions that return a function ) with moand is a very common programming style other functional programming languages. This is why curry decorator is included in this module. With curry decorator you can transform a function in a curried function: just pass some positional parameters and get back a function with the remaining ones.</p> <pre><code>@curry\ndef power(exp: int, base: int ) -&gt; int:\n    return math.pow(base, exp)\n\nsquare_fn = power(2) # a function that returns the square of the parameter\n\n</code></pre>"},{"location":"fastapi/","title":"Fn Fast.api","text":"<p>FastAPI is a modern, fast (high-performance), web framework for building APIs with Python.</p> <p>You can use a monadic structure to wrap the response of your endpoint</p> <pre><code>from monads import MonadicResponseMiddleware, HttpError\n\ndef check_not_found(x: Dict[str, Any]) -&gt; Maybe[HttpError]:\n    if is_not_found_error(x):\n        return Just(HttpError(404, \"The item was't there!\"))\n    else:\n        return Nothing()\n\n\nMonadicResponseMiddleware.add_monadic_response_middleware(app, [check_not_found])\n\ndef read_from_source(item_id) -&gt; Result[Item,str] # return an item or an error with a localized message\n    ...\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: str) -&gt; Result[Item, str]:\n    return read_from_source(item_id).map(lambda item: item.price = item.price * 1.2) # the transformation occurs only if there were no errors\n\n</code></pre> <p>The response is either the expected payload or, in case of error a list of objects, generated  by  the error checker Callables</p> <p>FastAPI support is under heavy development details may change in the future.</p>"},{"location":"functor/","title":"Functor","text":"<p>In mathematics, specifically category theory, a functor is a mapping between categories. In python is an object tha can be mapped to something else.</p>"},{"location":"functor/#map","title":"map (<code>*</code>)","text":"<p>Applies a function to the contents of a functor, transforming it from one thing to another.</p> <p>The <code>*</code> operator implements map on functors</p> <pre><code>def wordcount(s: str):\n    return len(s.split())\n\n\nf.map(wordcount) ==  f * wordcount\n</code></pre>"},{"location":"future/","title":"Future","text":"<p>Represents an asynchronous action.</p> <pre><code>\n# Lazy values and operations\nmapped_future: Future[int] = Future.pure(1).map(lambda x: x + 1)\nawait mapped_future\n\n# convert sync calls in  async\nf: Callable[[int], int] = lambda x: x + 1\nawait Future.pure(3).map(f) == await Future.pure(3).apply(Future.pure(f))\n\n</code></pre> <ul> <li>Also implements <code>Awaitable</code>.</li> </ul>"},{"location":"list/","title":"List","text":"<p>Represents a ordered sequence of items.</p> <ul> <li>Also implements <code>Monoid</code>.</li> </ul> <pre><code>\nm_list: List[int] = List([1, 2, 4, 9])\nfor i in m_list:\n    ...\n\n#Or filter with a generator\n\nevens: List[int] = [k for k in m_list if k % 2 == 0 ]\n\n# And use it like a monad\n\ndoubles: List[int] = m_list.map(lambda i : i * 2) \n\n# Mixing and matching oop and fn\n\nm_list.fold(lambda k, h: k + h, 0) == 16\n\n</code></pre>"},{"location":"list/#flatten","title":"Flatten","text":"<p>If you have a list of lists, and want to create one list (sequence) from them, use the flatten method to convert a list of lists into a single list</p> <pre><code>\nm_list: List[Union[int, List[int]]] = List([1, 2, List([3, 4])])\nlen(m_list.flatten()) == 4\n\n</code></pre>"},{"location":"maybe/","title":"Maybe","text":"<p>Undefined values or operations are one particular problem that robust software should prepare for and handle gracefully.</p> <p>A <code>Maybe</code> instance of a certain type <code>T</code> will either be a <code>Just</code> object wrapping a value of that type, or <code>Nothing</code>.</p> <ul> <li>Mapping a function over <code>Nothing</code> will return <code>Nothing</code> without   calling the function.</li> <li>Binding an operation with a <code>Nothing</code> will return <code>Nothing</code> without   attempting the operation.</li> </ul>"},{"location":"maybe/#default-value-with-or_else","title":"Default value with or_else","text":"<p>Is always nice to have a backup option:</p> <pre><code>\nm_empty: Maybe[str] = Nothing()\nm_empty.or_else(\"backup\") == \"backup\"\n\n</code></pre>"},{"location":"maybe/#differences-with-optional","title":"Differences with Optional","text":"<p>The main difference <code>Maybe</code> and <code>Optional</code> is that you can chain operations without <code>if guards</code> statelments. There is a lot of interoperability between the two types if you want to limit the usage of Typed Monads to your code only.</p> <pre><code>Just(2) == Maybe.fromOptional(2)\nNothing() == Maybe.fromOptional(None)\n2 == Just(2).toOptional()\nNone == Nothing().toOptional()\n</code></pre>"},{"location":"monad/","title":"What's a monad?","text":"<p>A monad is an abstraction that allows structuring programs generically. Monads achieve this by providing their own data type (a particular type for each type of monad), which represents a specific form of computation, along with one procedure to wrap values of any basic type within the monad (yielding a monadic value) and another to compose functions that output monadic values (called monadic functions). This allows monads to simplify a wide range of problems, like handling potential undefined values (with the Maybe monad), or keeping values within a flexible, well-formed list (using the List monad). With a monad, a programmer can turn a complicated sequence of functions into a succinct pipeline that abstracts away auxiliary data management, control flow, or side-effects.</p> <p>Extends <code>Applicative</code>.</p>"},{"location":"monad/#bind","title":"bind (<code>&gt;&gt;</code>)","text":"<p>Passes the value within the monad through an operation returning the same type of monad, allowing multiple operations to be chained.</p> <p>The <code>&gt;&gt;</code> operator implements bind on monads, and is left-associative.</p> <pre><code>@curry\ndef lookup(key: str, dictionary: Dict[str, str]) -&gt; Maybe[str]:\n    try:\n        return Just(dictionary[key])\n    except KeyError:\n        return Nothing()\n\n\nresult = Just({\"hello\": \"world\"}).bind(lookup(\"hello\")).bind(lambda s: s.upper())\nresult = (\n    Just({\"hello\": \"world\"})\n    &gt;&gt; lookup(\"hello\")\n    &gt;&gt; (lambda s: s.upper())\n)\n</code></pre>"},{"location":"monoid/","title":"Monoid","text":"<p>In abstract algebra, a monoid is a set equipped with an associative binary operation and an identity element. Monoids are semigroups with identity. Such algebraic structures occur in several branches of mathematics. For example, the functions from a set into itself form a monoid with respect to function composition. Many abstract data types can be endowed with a monoid structure. In a common pattern, a sequence of elements of a monoid is \"folded\" or \"accumulated\" to produce a final value.</p>"},{"location":"monoid/#mappend","title":"mappend (<code>+</code>)","text":"<p>Describes an associative binary operation for a type.</p>"},{"location":"monoid/#mzero","title":"mzero","text":"<p>Provides an identity value for the <code>mappend</code> operation.</p>"},{"location":"monoid/#mconcat","title":"mconcat","text":"<p>Accumulates a list of values using <code>mappend</code>. Returns the <code>mzero</code> value if the list is empty.</p>"},{"location":"mypy/","title":"MyPy support","text":"<p>WIP</p>"},{"location":"result/","title":"Result","text":"<p>Represents a state of success or failure, declaring a type for each. It is the monadic way to error handling. A <code>Result</code> instance will either be an <code>Ok</code> object wrapping a value of the success type <code>T</code>, or an <code>Err</code> object wrapping a value of the failure type <code>E</code>.</p> <ul> <li>Mapping a function over an <code>Err</code> will return the <code>Err</code> unchanged   without calling the function.</li> <li>Binding an operation with an <code>Err</code> will return the <code>Err</code> unchanged   without attempting the operation.</li> </ul> <pre><code>\nm: Result[int, str] = Ok(5)\nincrement: Callable[[int],int] = lambda x : x +1\nOk(6) == m.map(increment)\ne: Result[int, str] = Err(\"oops\")\nErr(\"oops\") == e.map(increment) # still an error\n\n</code></pre>"}]}